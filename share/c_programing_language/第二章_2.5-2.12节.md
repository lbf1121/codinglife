## week9 
### 2.5 算术运算符
* 二元算术运算符号：+、-、*、/、%（取模）。整数除法截断小数部分。
* 闰年（leap year）：能被4整除，不能被100整除。能被400整除的年份也是闰年。
```text
//判断是否为闰年：
if((year % 4 == 0 && year % 100 != 0) || year % 400 == 0){
    printf("%d is a leap year \n",year);
}else{
    printf("%d is not a leap year \n",year);
}
```
* 取模运算符 % 不能应用于 float 或 double 类型。
* 二元运算符+和-具有相同的优先级，它们的优先级比运算符*、/和%的优先级低，而运算符*、/和%的优先级又比一元运算符的+和-低。算术运算符采用从左到右的结合规则。
### 2.6 关系运算符与逻辑运算符
关系运算符：>、>=、<、<=，它们具有相同的优先级。优先级仅次于它们的是相等性运算符：==、!=。
* 关系运算符的优先级比算术运算符的优先级低。因此，表达式 i < limit -1 等价于 i < (limit -1) 
* 逻辑运算符：&&与||有一些较为特殊的属性，由于&&与||连接的表达式按从左到右的顺序进行求值，并且，在知道结果值真或假后立即停止计算。
* 逻辑非运算符!的作用是将非0操作数转换为1。该运算符通常用于下列类似结构中：if(!valid),一般不采用if(valid==0)。
### 2.7 类型转换
自动转换：指把"比较窄的"操作数转换为"比较宽的"操作数，是不丢失信息的转换。比如，int 转 float。
```C
/* atoi函数：将字符串 s 转换为相应的整型数 */
int atoi(char s[]){
    int i,n;
    n = 0;
    for(i = 0;s[i] >= '0' && s[i] <= '9';i++){
        n = s[i] * 10 + (s[i] - '0')
    }
    return n;
}
```
表达式：s[i] - '0' 能计算出 s[i] 中存储的字符说对应的数字值。字符集中对应的数值是一个连续的递增序列。
```C
/* 将字符c转为小写形式：只针对ASCII码字符集有效 */
int lower(int c){
    if(c >= 'A' && c <= 'Z'){
        return c + 'a' - 'A';
        //return c + 32;
    }else{
        return c;
    }
}
```
* 为了保证程序的可移植性，如果要在char类型的变量中存储非字符数据，最好指定signed 或 unsigned 限定符。
* 当关系表达式（如i>j）以及由&&、||连接的逻辑表达式的判定结果为真时，表达式的值为1；当判定结果为假时，表达式的结果为0。
* 在if、while、for等语句的测试部分中，真意味着"非0"。
#### 隐式的算术类型转换
在运算前，将较低的类型提升为较高的类型，运算结果为较高的类型。
##### 没有unsigned类型操作
* 如果其中一个操作数的类型为long double，则另一个操作数转换为long double类型；
* 如果其中一个操作数的类型为double，则另一个操作数转换为double类型；
* 如果其中一个操作数的类型为float，则另一个操作数转换为float类型；
* 将char与short类型的操作数转换为int类型；
* 如果其中一个操作数的类型为long，则另一个操作数转换为long类型；
注意：表达式中的float类型的操作数不会自动转换为double类型。数学函数一般使用双精度类型，使用float类型主要是为了在使用较大的数组时节省空间，有时也是为了节省执行时间（双精度算术运算特别费时）。
##### 包含unsigned
带符号值与无符号值之间的比较是与机器相关的，因为它取决于机器中不同整数类型的大小。
```text
假定int类型占16位，long类型占32位，那么-1L<1U，这是因为unsigned int类型的1U被提升为signed long类型；但是-1L>1UL，这是因为-1L将被提升为unsigned long类型，因而成为一个比较大的正数。
```
##### 赋值时也要进行类型转换 
赋值运算符右边的值需要转换为左边变量的类型，左边变量的类型即赋值表达式的结果类型。
* 将double类型转换为float类型时，是进行四舍五入还是截取取决于具体的实现。
##### 把参数传递给函数时也可能进行类型转换
因为函数的参数是表达式，所以把参数传递给函数时也可能进行类型转换。在没有函数原型的情况下，char与short都将被转换为int类型，float类型将被转换为double类型。因此，即使调用函数的参数是char或float类型，我们也把函数参数声明为int或double类型。
##### 强制类型转换
在任何表达式中都可以使用一个称为强制类型转换的一元运算符强制进行显示类型转换。
```text
（类型名）表达式

unsigned long int next = 1;
/* rand函数：返回取值在0~32767之间的伪随机数 */
int rand(void){
    next = next * 1103515245 + 12345;
    return (unsigned int)(next/65536) % 32768;
}

/* srand函数：为rand()函数设置种子数 */
void srand(unsigned int seed){
    next = seed;
}
```
### 2.8 自增运算符与自减运算符
* 自增：++，使其操作数递增1
* 自减：--，使其操作数递减1
它们既可以做前缀运算符，也可以做后缀运算符。区别：表达式++n先将n的值递增1，然后再使用变量n的值；表达式n++，先使用变量n的值，然后在将n的值递增1。
```text
int n = 5;
int x = 0;
x = n++;
printf(x); //x = 5

x = ++n;
printf(x); //x = 6
```
* 自增、自减运算符只能作用于变量。
### 2.9 按位运算符
C语言提供了6个位操作运算符，这些操作符只能作用于整型操作数，即只能作用于带符号或无符号的char、short、int与long类型：
* &  按位与（AND） 
* |  按位或（OR）
* ^  按位异或（XOR）
* << 左移
* >> 右移
* ~  按位求反（一元运算符）
#### 按位与 & 运算符经常用于屏蔽某些二进制位
例如：
```text
    n = n & 0177;
```
该语句将n中除7个低二进制位外的其他各位均置为0.
#### 按位或 | 运算符经常用于将某些二进制位置为1
例如：
```text
    x = x | set_no;
```
该语句将x中对应于set_no中为1的那些二进制位置为1
#### 按位异或 ^ 当两个操作数对应位不同时将该位设置为1，否则，将该位设置为0.
必须将按位运算符 &、| 同逻辑运算符 &&、|| 区分开来，后者用于从左到右求表达式真值。
例如，如果xd的值为1，y的值为2，x & y 结果为0，而 x && y 结果为1.
#### 移位运算符 << 与 >> 分别用于将操作数左移与右移，移动的位数则由右操作数指定(右操作数的值必须是非负值)。
因此，表达式x<<2将把x的值

### 2.10 赋值运算符与表达式

### 2.11 条件表达式

### 2.12 运算符优先级与求值次序

 
