## week9 
### 2.5 算术运算符
* 二元算术运算符号：+、-、*、/、%（取模）。整数除法截断小数部分。
* 闰年（leap year）：能被4整除，不能被100整除。能被400整除的年份也是闰年。
```text
//判断是否为闰年：
if((year % 4 == 0 && year % 100 != 0) || year % 400 == 0){
    printf("%d is a leap year \n",year);
}else{
    printf("%d is not a leap year \n",year);
}
```
* 取模运算符 % 不能应用于 float 或 double 类型。
* 二元运算符+和-具有相同的优先级，它们的优先级比运算符*、/和%的优先级低，而运算符*、/和%的优先级又比一元运算符的+和-低。算术运算符采用从左到右的结合规则。
### 2.6 关系运算符与逻辑运算符
关系运算符：>、>=、<、<=，它们具有相同的优先级。优先级仅次于它们的是相等性运算符：==、!=。
* 关系运算符的优先级比算术运算符的优先级低。因此，表达式 i < limit -1 等价于 i < (limit -1) 
* 逻辑运算符：&&与||有一些较为特殊的属性，由于&&与||连接的表达式按从左到右的顺序进行求值，并且，在知道结果值真或假后立即停止计算。
* 逻辑非运算符!的作用是将非0操作数转换为1。该运算符通常用于下列类似结构中：if(!valid),一般不采用if(valid==0)。
### 2.7 类型转换
自动转换：指把"比较窄的"操作数转换为"比较宽的"操作数，是不丢失信息的转换。比如，int 转 float。
```C
/* atoi函数：将字符串 s 转换为相应的整型数 */
int atoi(char s[]){
    int i,n;
    n = 0;
    for(i = 0;s[i] >= '0' && s[i] <= '9';i++){
        n = s[i] * 10 + (s[i] - '0')
    }
    return n;
}
```
表达式：s[i] - '0' 能计算出 s[i] 中存储的字符说对应的数字值。字符集中对应的数值是一个连续的递增序列。
```C
/* 将字符c转为小写形式：只针对ASCII码字符集有效 */
int lower(int c){
    if(c >= 'A' && c <= 'Z'){
        return c + 'a' - 'A';
        //return c + 32;
    }else{
        return c;
    }
}
```
* 为了保证程序的可移植性，如果要在char类型的变量中存储非字符数据，最好指定signed 或 unsigned 限定符。
* 当关系表达式（如i>j）以及由&&、||连接的逻辑表达式的判定结果为真时，表达式的值为1；当判定结果为假时，表达式的结果为0。
* 在if、while、for等语句的测试部分中，真意味着"非0"。
#### 隐式的算术类型转换
在运算前，将较低的类型提升为较高的类型，运算结果为较高的类型。
##### 没有unsigned类型操作
* 如果其中一个操作数的类型为long double，则另一个操作数转换为long double类型；
* 如果其中一个操作数的类型为double，则另一个操作数转换为double类型；
* 如果其中一个操作数的类型为float，则另一个操作数转换为float类型；
* 将char与short类型的操作数转换为int类型；
* 如果其中一个操作数的类型为long，则另一个操作数转换为long类型；
注意：表达式中的float类型的操作数不会自动转换为double类型。数学函数一般使用双精度类型，使用float类型主要是为了在使用较大的数组时节省空间，有时也是为了节省执行时间（双精度算术运算特别费时）。
##### 包含unsigned
带符号值与无符号值之间的比较是与机器相关的，因为它取决于机器中不同整数类型的大小。
```text
假定int类型占16位，long类型占32位，那么-1L<1U，这是因为unsigned int类型的1U被提升为signed long类型；但是-1L>1UL，这是因为-1L将被提升为unsigned long类型，因而成为一个比较大的正数。
```
##### 赋值时也要进行类型转换 
赋值运算符右边的值需要转换为左边变量的类型，左边变量的类型即赋值表达式的结果类型。
* 将double类型转换为float类型时，是进行四舍五入还是截取取决于具体的实现。
##### 把参数传递给函数时也可能进行类型转换
因为函数的参数是表达式，所以把参数传递给函数时也可能进行类型转换。在没有函数原型的情况下，char与short都将被转换为int类型，float类型将被转换为double类型。因此，即使调用函数的参数是char或float类型，我们也把函数参数声明为int或double类型。
##### 强制类型转换
在任何表达式中都可以使用一个称为强制类型转换的一元运算符强制进行显示类型转换。
```text
（类型名）表达式

unsigned long int next = 1;
/* rand函数：返回取值在0~32767之间的伪随机数 */
int rand(void){
    next = next * 1103515245 + 12345;
    return (unsigned int)(next/65536) % 32768;
}

/* srand函数：为rand()函数设置种子数 */
void srand(unsigned int seed){
    next = seed;
}
```
### 2.8 自增运算符与自减运算符
* 自增：++，使其操作数递增1
* 自减：--，使其操作数递减1
它们既可以做前缀运算符，也可以做后缀运算符。区别：表达式++n先将n的值递增1，然后再使用变量n的值；表达式n++，先使用变量n的值，然后在将n的值递增1。
```text
int n = 5;
int x = 0;
x = n++;
printf(x); //x = 5

x = ++n;
printf(x); //x = 6
```
* 自增、自减运算符只能作用于变量。
### 2.9 按位运算符
C语言提供了6个位操作运算符，这些操作符只能作用于整型操作数，即只能作用于带符号或无符号的char、short、int与long类型：
* &  按位与（AND） 
* |  按位或（OR）
* ^  按位异或（XOR）
* << 左移
* >> 右移
* ~  按位求反（一元运算符）
#### 按位与 & 运算符经常用于屏蔽某些二进制位
例如：
```text
    n = n & 0177;
```
该语句将n中除7个低二进制位外的其他各位均置为0.
#### 按位或 | 运算符经常用于将某些二进制位置为1
例如：
```text
    x = x | set_no;
```
该语句将x中对应于set_no中为1的那些二进制位置为1
#### 按位异或 ^ 当两个操作数对应位不同时将该位设置为1，否则，将该位设置为0.
必须将按位运算符 &、| 同逻辑运算符 &&、|| 区分开来，后者用于从左到右求表达式真值。
例如，如果xd的值为1，y的值为2，x & y 结果为0，而 x && y 结果为1.
#### 移位运算符 << 与 >> 分别用于将操作数左移与右移，移动的位数则由右操作数指定(右操作数的值必须是非负值)。
因此，表达式x<<2将把x的值左移2位，右边空出的2位用0填补，该操作等价于对做操作数乘以4。在对unsigned类型的无符号值进行右移时，左面空出的部分将用0填补；
当对signed类型的带符号值进行右移时，某些机器将对左边空出的部分用符号位填补（即"算术移位"），而另一些机器则对左边空出来的部分用0填补（即"逻辑移位"）。

* *尚未理解左移、右移运算，需要花更多时间学习*

#### 复习二进制数
##### 原码：一个正数，按照绝对值大小转换成的二进制数；一个负数按照绝对值大小转换成的二进制数，然后最高位补1，称为原码
```text
    00000000 00000000 00000000 00000101 是 5的 原码
    10000000 00000000 00000000 00000101 是 -5的 原码
```
如果有符号， 二进制最高位表示符号,0为正,1为负
##### 反码：正数的反码与原码相同，负数的反码为对该数的原码除符号位外各位取反[每一位取反(除符号位)]。
```text
    正数00000000 00000000 00000000 00000101 的反码还是 00000000 00000000 00000000 00000101      
    负数10000000 00000000 00000000 00000101 的反码则是 11111111 11111111 11111111 11111010
    
    反码是相互的，所以也可称：10000000 00000000 00000000 00000101 和 11111111 11111111 11111111 11111010互为反码
```
##### 补码:正数的补码与原码相同，负数的补码为对该数的原码除符号位外各位取反，然后在最后一位加1
```text
   10000000 00000000 00000000 00000101 的反码是：11111111 11111111 11111111 11111010
   那么，补码为：11111111 11111111 11111111 11111010 + 1 = 11111111 11111111 11111111 11111011
```
负数二进制形式表示：以原码的补码形式表达
* *1、从补码求原码的方法跟原码求补码是一样的 ，也可以通过完全逆运算来做，先减一，再取反。*
* *2、补码却规定0没有正负之分*
##### 特殊情况-128
```text
1000 0000,那么,它的原码是什么呢?从补码求原码的方法跟原码求补码是一样的。
先保留符号位其它求反:  11111111, 再加1，11000 0000, 超过了8位了。
对,用8位数的原码在这里已经无法表示了。
那么,回到原码处, 它的原码也是 1000 0000(超出的自动丢失),1000 0000 在原码表示什么呢? 
-0, 但补码却规定0没有正负之分。
转换一下思路,看看计算机里,是怎么运算的:
对于负数,先取绝对值,然后求反,加一
-128 -> 128 -> 1000 0000 -> 0111 1111 -> 1000 0000
所以, 8位有符号的整数取值范围的补码表示
1000 0000 到 0000 0000, 再到 0111 1111
即 -128 到 0, 再到 127
最终 -128 ~ +127
```
* 参考[负数的二进制表示方法](https://blog.csdn.net/diandianxiyu_geek/article/details/44098121)
##### 位运算小技巧
* [位运算简介及实用技巧：基础篇](http://www.matrix67.com/blog/archives/263)
* [位运算简介及实用技巧：进阶篇(1)](http://www.matrix67.com/blog/archives/264)
* [位运算简介及实用技巧：进阶篇(2)](http://www.matrix67.com/blog/archives/266)
* [位运算简介及实用技巧：实战篇](http://www.matrix67.com/blog/archives/268)
* [位运算实用技巧(Java实现)](https://www.jianshu.com/p/054b0b361cf8)
* [位操作基础篇之位操作全面总结](https://blog.csdn.net/morewindows/article/details/7354571)

### 2.10 赋值运算符与表达式
赋值运算符：op=，op可以是：+ , - , * , / , % , << , >> , & , ^ , |
```text
/* bitcount函数：统计x中值为1的二进制位数 */
int bitcount(unsigned x){
    int b;
    for(b=0;x!=0;x>>=1)
        if(x & 01)
            b++;
    return b;
}
//将x声明为unsigned无符号类型是为了确保将x右移时，不论该程序在什么机器上运行，左边空出来的位都用0（而不是符号位）填补。
```
### 2.11 条件表达式
* 条件表达式使用三元运算符 ?
```text
    expr1 ? expr2:expr3;    //expr1 为真，计算expr2，否则计算expr3
    
    n > 0 ? f : n;  
```
### 2.12 运算符优先级与求值次序
```text
 运算符                             结合性    
 () [] -> .                        从左至右    ^                                   从左至右
 ! ~ ++ -- + - * & (type) sizeof   从右至左    |                                   从左至右
 * / %                             从左至右    &&                                  从左至右
 + -                               从左至右    ||                                  从左至右
 <<  >>                            从左至右    ?:                                  从右至左
 <   <=   >   >=                   从左至右    =  +=  -=  *=  /=  %=  &=           从右至左
 ==  !=                            从左至右    ^=  |=  <<=  >>=                    从右至左
 &                                 从左至右    ,                                   从左至右
 
```
* 一元运算符 + 、 - 、& 与 * 比相应的二元运算符 + 、- 、& 与 * 的优先级高

